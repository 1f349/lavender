// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: users.sql

package database

import (
	"context"
	"database/sql"
	"time"
)

const addUser = `-- name: AddUser :exec
INSERT INTO users (subject, email, email_verified, roles, userinfo, updated_at, active)
VALUES (?, ?, ?, ?, ?, ?, ?)
`

type AddUserParams struct {
	Subject       string    `json:"subject"`
	Email         string    `json:"email"`
	EmailVerified bool      `json:"email_verified"`
	Roles         string    `json:"roles"`
	Userinfo      string    `json:"userinfo"`
	UpdatedAt     time.Time `json:"updated_at"`
	Active        bool      `json:"active"`
}

func (q *Queries) AddUser(ctx context.Context, arg AddUserParams) error {
	_, err := q.db.ExecContext(ctx, addUser,
		arg.Subject,
		arg.Email,
		arg.EmailVerified,
		arg.Roles,
		arg.Userinfo,
		arg.UpdatedAt,
		arg.Active,
	)
	return err
}

const getUser = `-- name: GetUser :one
SELECT subject, email, email_verified, roles, userinfo, access_token, refresh_token, expiry, updated_at, active
FROM users
WHERE subject = ?
LIMIT 1
`

func (q *Queries) GetUser(ctx context.Context, subject string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUser, subject)
	var i User
	err := row.Scan(
		&i.Subject,
		&i.Email,
		&i.EmailVerified,
		&i.Roles,
		&i.Userinfo,
		&i.AccessToken,
		&i.RefreshToken,
		&i.Expiry,
		&i.UpdatedAt,
		&i.Active,
	)
	return i, err
}

const getUserEmail = `-- name: GetUserEmail :one
SELECT email
FROM users
WHERE subject = ?
`

func (q *Queries) GetUserEmail(ctx context.Context, subject string) (string, error) {
	row := q.db.QueryRowContext(ctx, getUserEmail, subject)
	var email string
	err := row.Scan(&email)
	return email, err
}

const getUserRoles = `-- name: GetUserRoles :one
SELECT roles
FROM users
WHERE subject = ?
`

func (q *Queries) GetUserRoles(ctx context.Context, subject string) (string, error) {
	row := q.db.QueryRowContext(ctx, getUserRoles, subject)
	var roles string
	err := row.Scan(&roles)
	return roles, err
}

const getUserToken = `-- name: GetUserToken :one
SELECT access_token, refresh_token, expiry
FROM users
WHERE subject = ?
LIMIT 1
`

type GetUserTokenRow struct {
	AccessToken  sql.NullString `json:"access_token"`
	RefreshToken sql.NullString `json:"refresh_token"`
	Expiry       sql.NullTime   `json:"expiry"`
}

func (q *Queries) GetUserToken(ctx context.Context, subject string) (GetUserTokenRow, error) {
	row := q.db.QueryRowContext(ctx, getUserToken, subject)
	var i GetUserTokenRow
	err := row.Scan(&i.AccessToken, &i.RefreshToken, &i.Expiry)
	return i, err
}

const hasUser = `-- name: HasUser :one
SELECT count(subject) > 0 AS hasUser
FROM users
`

func (q *Queries) HasUser(ctx context.Context) (bool, error) {
	row := q.db.QueryRowContext(ctx, hasUser)
	var hasuser bool
	err := row.Scan(&hasuser)
	return hasuser, err
}

const updateUserInfo = `-- name: UpdateUserInfo :exec
UPDATE users
SET email          = ?,
    email_verified = ?,
    userinfo       = ?
WHERE subject = ?
`

type UpdateUserInfoParams struct {
	Email         string `json:"email"`
	EmailVerified bool   `json:"email_verified"`
	Userinfo      string `json:"userinfo"`
	Subject       string `json:"subject"`
}

func (q *Queries) UpdateUserInfo(ctx context.Context, arg UpdateUserInfoParams) error {
	_, err := q.db.ExecContext(ctx, updateUserInfo,
		arg.Email,
		arg.EmailVerified,
		arg.Userinfo,
		arg.Subject,
	)
	return err
}

const updateUserToken = `-- name: UpdateUserToken :exec
UPDATE users
SET access_token  = ?,
    refresh_token = ?,
    expiry        = ?
WHERE subject = ?
`

type UpdateUserTokenParams struct {
	AccessToken  sql.NullString `json:"access_token"`
	RefreshToken sql.NullString `json:"refresh_token"`
	Expiry       sql.NullTime   `json:"expiry"`
	Subject      string         `json:"subject"`
}

func (q *Queries) UpdateUserToken(ctx context.Context, arg UpdateUserTokenParams) error {
	_, err := q.db.ExecContext(ctx, updateUserToken,
		arg.AccessToken,
		arg.RefreshToken,
		arg.Expiry,
		arg.Subject,
	)
	return err
}
